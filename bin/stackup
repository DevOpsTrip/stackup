#!/usr/bin/env ruby

$LOAD_PATH << File.expand_path("../../lib", __FILE__)

require "clamp"
require "console_logger"
require "diffy"
require "multi_json"
require "stackup"
require "stackup/version"
require "yaml"

Clamp do

  option ["-L", "--list"], :flag, "list stacks" do
    list_stacks
    exit 0
  end

  option ["-Y", "--yaml"], :flag, "output data in YAML format"

  option "--debug", :flag, "enable debugging"

  option ["--version"], :flag, "display version" do
    puts "stackup v#{Stackup::VERSION}"
    exit 0
  end

  parameter "NAME", "Name of stack", :attribute_name => :stack_name

  def run(arguments)
    super(arguments)
  rescue Stackup::ServiceError => e
    signal_error e.message
  rescue Aws::Errors::MissingCredentialsError
    signal_error "no credentials provided"
  rescue Aws::CloudFormation::Errors::ExpiredToken => e
    signal_error e.message
  end

  private

  def logger
    @logger ||= ConsoleLogger.new($stdout, debug?)
  end

  def format_data(data)
    if yaml?
      YAML.dump(data)
    else
      MultiJson.dump(data, :pretty => true)
    end
  end

  def display_data(data)
    puts format_data(data)
  end

  def stackup
    Stackup(:logger => logger, :log_level => :debug)
  end

  def stack
    stackup.stack(stack_name)
  end

  def list_stacks
    stackup.stack_names.each do |name|
      puts name
    end
  end

  def report_change
    final_status = yield
    puts final_status unless final_status.nil?
  end

  def load_data(file)
    YAML.load_file(file)
  rescue Errno::ENOENT
    signal_error "no such file: #{file.inspect}"
  end

  subcommand "status", "Print stack status." do

    def execute
      puts stack.status
    end

  end

  subcommand "up", "Create/update the stack" do

    option ["-t", "--template"], "FILE", "template file",
           :attribute_name => :template_file

    option ["-T", "--use-previous-template"], :flag,
           "reuse the existing template"

    option ["-p", "--parameters"], "FILE", "parameters file",
           :attribute_name => :parameters_file

    option "--policy", "FILE", "stack policy file",
           :attribute_name => :policy_file

    option "--on-failure", "ACTION",
           "when stack creation fails: DO_NOTHING, ROLLBACK, or DELETE",
           :default => "ROLLBACK"

    def execute
      unless template_file || use_previous_template?
        signal_usage_error "Specify either --template or --use-previous-template"
      end
      options = {}
      options[:template] = load_data(template_file) if template_file
      options[:on_failure] = on_failure
      options[:parameters] = load_data(parameters_file) if parameters_file
      options[:stack_policy] = load_data(policy_file) if policy_file
      options[:use_previous_template] = use_previous_template?
      report_change do
        stack.create_or_update(options)
      end
    end

  end

  subcommand "diff", "Compare template/params to current stack." do

    option ["-t", "--template"], "FILE", "template file",
           :attribute_name => :template_file

    option ["-p", "--parameters"], "FILE", "parameters file",
           :attribute_name => :parameters_file

    option "--diff-format", "FORMAT", "'text', 'color', or 'html'", :default => "color"

    def execute
      # rubocop:disable Style/GuardClause
      if template_file
        template = load_data(template_file)
        diff_data(stack.template, template)
      end
      if parameters_file
        new_parameters = hashify_parameters(load_data(parameters_file))
        existing_parameters = stack.parameters
        new_parameters = existing_parameters.merge(new_parameters)
        diff_data(existing_parameters.sort.to_h, new_parameters.sort.to_h)
      end
    end

    private

    def diff_data(existing_data, pending_data)
      existing = format_data(existing_data) + "\n"
      pending = format_data(pending_data) + "\n"
      diff = Diffy::Diff.new(existing, pending).to_s(diff_format.to_sym)
      return if diff =~ /\A\s*\Z/
      puts diff
    end

    def hashify_parameters(parameters)
      return parameters unless parameters.is_a?(Array)
      {}.tap do |result|
        parameters.each do |p|
          key = p.fetch("ParameterKey") { p.fetch("parameter_key") }
          value = p.fetch("ParameterValue") { p.fetch("parameter_value") }
          result[key] = value
        end
      end
    end

  end

  subcommand ["down", "delete"], "Remove the stack." do

    def execute
      report_change do
        stack.delete
      end
    end

  end

  subcommand "cancel-update", "Cancel the update in-progress" do

    def execute
      report_change do
        stack.cancel_update
      end
    end

  end

  subcommand "wait", "Wait until stack is stable" do

    def execute
      puts stack.wait
    end

  end

  subcommand "events", "List stack events" do

    option ["-f", "--follow"], :flag, "follow new events"
    option ["--data"], :flag, "display events as data"

    def execute
      stack.watch(false) do |watcher|
        loop do
          watcher.each_new_event do |event|
            display_event(event)
          end
          break unless follow?
          sleep 5
        end
      end
    end

    private

    def display_event(e)
      if data?
        display_data(event_data(e))
      else
        puts event_summary(e)
      end
    end

    def event_data(e)
      {
        "timestamp" => e.timestamp.localtime,
        "logical_resource_id" => e.logical_resource_id,
        "physical_resource_id" => e.physical_resource_id,
        "resource_status" => e.resource_status,
        "resource_status_reason" => e.resource_status_reason
      }.reject { |_k, v| blank?(v) }
    end

    def blank?(v)
      v.nil? || v.respond_to?(:empty?) && v.empty?
    end

    def event_summary(e)
      summary = "[#{e.timestamp.localtime.iso8601}] #{e.logical_resource_id}"
      summary += " - #{e.resource_status}"
      summary += " - #{e.resource_status_reason}" if e.resource_status_reason
      summary
    end

  end

  subcommand "template", "Display stack template." do

    def execute
      display_data(stack.template)
    end

  end

  subcommand "parameters", "Display stack parameters." do

    def execute
      display_data(stack.parameters)
    end

  end

  subcommand "resources", "Display stack resources." do

    def execute
      display_data(stack.resources)
    end

  end

  subcommand "outputs", "Display stack outputs." do

    def execute
      display_data(stack.outputs)
    end

  end

  subcommand "inspect", "status + parameters + resources + outputs" do

    def execute
      data = {
        "Status" => stack.status,
        "Parameters" => stack.parameters,
        "Resources" => stack.resources,
        "Outputs" => stack.outputs,
      }
      display_data(data)
    end

  end

end
